<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
	<title>5.2. Управление процессами</title>
</head>
<link rel="stylesheet" href="../../styles.css">
<body style="margin: 0px 150px 0px 150px">

<table summary="Header navigation table" width="100%" border="0" cellpadding="0"
cellspacing="0">
<tr>
<th colspan="3" align="center">Администрирование Calmira GNU/Linux</th>
</tr>

<table summary="Footer navigation table" width="100%" border="0" cellpadding="0"
cellspacing="0">
<tr>
<td width="33%" align="left" valign="top"><a href="processes.html"
accesskey="P">Назад</a></td>
<td width="34%" align="center" valign="top"><a href="index.html"
accesskey="H">Домой</a></td>
<td width="34%" align="right" valign="top"><a href="users.html"
accesskey="N">Далее</a></td>

</tr>

<tr>
<td width="33%" align="left" valign="top">Права доступа</td>
<td width="34%" align="center" valign="top">&nbsp;</td>
<td width="33%" align="right" valign="top">Управление пользователями</td>
</tr>
</table>

<hr align="LEFT" width="100%" />

<h1>5.2. Управление процессами</h1>

<h2>Введение</h2>

<p>Процесс в Linux (как и в UNIX) - это программа, которая выполняется в отдельном виртуальном адресном пространстве. Такая абстракция, с помощью которой можно управлять памятью, временем работы процесора и ресурсами ввода/вывода.</p>

<p>Процессы защищены друг от друга и крах одного процесса не повлияет на работу других и всей системы в целом. Один процесс не может прочитать (или записать) данные другого процесса без его разрешения на это, а санкционированное взаимодействие друг с другом разрешено системой.</p>

<p>Процесс состоит из адресного пространства и набора структур данных внутри ядра. Адресное пространство - набор страниц памяти, выделенных ядром для использования процессу.</p>

<p>Для создания процессов используются два системных вызова: <tt>fork()</tt> и <tt>exec</tt>. <tt>fork()</tt> создаёт новое адресное пространство, которое полностью идентично адресному пространству другого процесса. После выполнения <tt>fork()</tt> получается два абсолютно одинаковых процесса - <em>основной</em> и <em>порождённый</em>.</p>

<p>Каждый процесс в системе имеет уникальный идентификатор - <em>Process ID</em>. Этот номер используется ядром и специализированными утилитами для работы с процессами.</p>

<p>Пользователь может управлять поведением процессов, запущенных от его имени. Но только <tt>root</tt> имеет право управления всеми процессами - и его, и других пользователей. Управление процессами производится специально предназначенными для этого утилитами, а так же некоторыми командами оболочки (shell)</p>

<h2>Выполнение процессов</h2>

<p>Есть несколько типов процессов:</p>

<ol>
	<li><b>Процессы переднего плана (foreground)</b>. На переднем плане в каждый момент для текущего терминала может выполняться только один процесс. Однако пользователь может перейти в другой TTY и запустить ещё один. ППП получает информацию с клавиатуры (<tt>stdin</tt>) и выводит результат на экран (<tt>stdout</tt>). Такие процессы иногда называют <em>интерактивными</em>;</li>
	<li><b>Фоновые (автоматические) процессы</b> отвязаны от терминала и не ожидают пользовательского ввода, а командная оболочка не ожидает окончания запущенного процесса, что позволяет пользователю запустить ещё один процесс;</li>
	<li><b>Отложенные процессы</b> в данный момент не выполняются и в данный момент остановлены. Их можно восстановить как на переднем плане, так и в фоне. Возобновление приостановленного процесса не изменит его состояния - он продолжит свою работу с того места, с которого был восстановлен;</li>
	<li><b>Демоны</b> - особый тип фоновых процессов, которые запускаются при старте системы и продолжают работу в виде службы;</li>
</ol>

<h2>PID, PPID</h2>

<p>Ядро назначает каждому процессу уникальный идентификатор (PID - Process Identification). На сегодня Linux использует концепцию пространства имён процесса, которая ещё больше ограничивает способность процессов видеть и влиять друг на друга. Недостаток в том, что процесс может иметь разные PID в зависимости от пространства имён наблюдателя.</p>

<p>Для того, чтобы создать новый процесс, существующий должен клонировать сам себя. Клон может заменить выполняемую программу другой.</p>

<p>Исходный процесс называется <em>родительским</em>, клон - <em>дочерним</em>. Каждый дочерний процесс имеет Parent Process ID (PPID).</p>

<h2>Другие идентификаторы</h2>

<p>Существует ещё несколько идентификаторов процессов, которые пригодятся при администрировании Calmira и других дистрибутивов Linux.</p>

<p>UID (User ID) - это идентификатор пользователя, создавшего данный процесс - копия UID родительского процесса. Менять атрибуты могут только его владелец (тот, кто его создал) и суперпользователь.</p>

<p>EUID (Effective User ID) - текущий пользовательский идентификатор процесса, предназначенный для определения, к каким ресурсам и файлам есть право доступа в данный момент. У большинства процессов значения UID и EUID одинаковые, кроме тех, у которых установлен бит смены идентификатора пользователя <tt>setuid</tt>.</p>

<p>Так же может встречаться довольно редкий и нестандартный параметр FSUID, определяющий возможности работы с ФС, но он используется очень редко.</p>

<p>GID (Group ID) - идентификационный номер группы данного процесса. EGID связан с GID так же, как EUID с UID.</p>

<h2>Жизненный цикл процесса</h2>

<p>Все процессы, кроме <tt>init</tt>, создаются с помощью системного вызова <tt>fork()</tt>. Вызывая эту функцию, процесс создаёт свой дубликат, называемый дочерним процессом (см. предыдущие пункты). Дочерний процесс - копия родительского, но с отличиями:</p>

<ol>
	<li>У дочернего процесса свой PID;</li>
	<li>PPID дочернего процесса равен PPID'у родительского.</li>
</ol>

<p>После вызова <tt>fork()</tt> может посредством системного вызова <tt>wait()</tt>/<tt>waitpid()</tt> приостановить своё выполнение до завершения дочернего процесса, или продолжать свою работу независимо от него. Процесс завершает своё выполнение вызовом функции <tt>exit()</tt></p>

<h2>Использование программ для работы с процессами</h2>

<h3><tt>kill</tt> для отправки сигналов; <tt>pidof</tt> для определения PID процессов</h3>

<p>Два основных сигнала - <tt>SIGTERM</tt> и <tt>SIGKILL</tt>. Первый запрашивает остановку процесса, который работает. Этот сигнал может быть проигнорирован. Процессу даётся некоторое время, чтобы он корректно завершился. Второй (<tt>SIGKILL</tt>) заставляет процесс прекратить своё выполнение немедленно. Программа не может проигнорировать этот сигнал.</p>

<h4>Синтаксис <tt>kill</tt></h4>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
kill &lt;сигнал&gt; PID
</pre></td></tr></table>

<p>Если сигнал не указан, то булет использоваться тот, что по умолчанию - SIGTERM. Если это не помогает, что можно использовать одну из следующих команд для принудительного завершения процесса:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
kill SIGKILL PID

# Или
kill -9 PID
</pre></td></tr></table>

<h4>Наиболее часто используемые сигналы</h4>

<ol>
	<li><b>1</b> (<tt>HUP</tt>) - перезапустить процесс;</li>
	<li><b>9</b> (<tt>KILL</tt>) - убить процесс;</li>
	<li><b>15</b> (<tt>TERM</tt>) - остановить процесс;</li>
</ol>

<h4>Дополнительные сведения</h4>

<p>Вы можете не знать PID нужного процесса. В таком случае можете использовать системные мониторы <tt>top</tt>, <tt>htop</tt>, которые предоставляются в портах, либо использовать "изкоробочные" решения, такие как <tt>pidof</tt>:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
pidof vim
</pre></td></tr></table>

<p>Команда выше выведет вам PID текстового редактора <tt>Vim</tt>.</p>

<p>Можно поступить проще. Если вы не знаете PID нужного процесса, то можно не выполнять последовательно <tt>pidof</tt> и <tt>kill</tt> - можно объединить их в одну команду:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
kill $(pidof vim)
</pre></td></tr></table>

<h3>Использование <tt>ps</tt> для мониторинга текущих работающих процессов</h3>

<p>Программа <tt>ps</tt> один из основных инструментов системного администратора для контроля процессов. Эта программа будет доступна даже тогда, когда не будет смонтирован раздел <tt>/usr</tt> (либо его вообще не будет). С помощью этой программы можно получить информацию об имени процесса, его PID, UID, приоритете, используемой памяти и пр.</p>

<p>Для просмотра списка всех процессов используется опция <tt>aux</tt>. <tt>a</tt> означает, что требуется вывести все процессы, <tt>x</tt> - даже те процессы, отсоединённые от управляющего терминала, <tt>u</tt> - фильтрация по имени или идентификатору пользователя.</p>

<p>На скриншоте ниже показан вывод <tt>ps aux |less</tt> (команда <tt>ps aux</tt> объединена в конвейер с утилитой <tt>less</tt> для возможности прокрутки вывода, если он не умещается на экран).</p>

<img src="pic/ps.png"></img>

<p><em>Табл. 1 - колонки таблицы вывода <tt>ps aux</tt></em></p>

<table border="1" width="100%" cellpadding="5">
	<tr>
		<td><b>Колонка</b></td>
		<td><b>Объяснение</b></td>
	</tr>
	<tr>
		<td><tt>USER</tt></td>
		<td>Владелец процесса</td>
	</tr>
	<tr>
		<td><tt>PID</tt></td>
		<td>Process ID</td>
	</tr>
	<tr>
		<td><tt>%CPU</tt></td>
		<td>Доля времени ЦП, выделенная процессу (в процентах)</td>
	</tr>
	<tr>
		<td><tt>%MEM</tt></td>
		<td>Сколько реальной памяти занято процессом (в процентах)</td>
	</tr>
	<tr>
		<td><tt>VSZ</tt></td>
		<td>Виртуальный размер процесса</td>
	</tr>
	<tr>
		<td><tt>RSS</tt></td>
		<td>Кол-во страниц памяти (размер резидентного набора)</td>
	</tr>
	<tr>
		<td><tt>TTY</tt></td>
		<td>В каком TTY запущено (идентификатор управляющего терминала) - выделено красным<br><img src="pic/tty.png"></img></td>
	</tr>
	<tr>
		<td><tt>STAT</tt></td>
		<td>Текущий статус процесса:
			<ol>
				<li><tt>R</tt> - выполняется;</li>
				<li><tt>D</tt> - ожидает записи на диск;</li>
				<li><tt>S</tt> - неактивен;</li>
				<li><tt>T</tt> - приостановлен;</li>
				<li><tt>Z</tt> - зомби.</li>
			</ol>
			Дополнительные:
			<ol>
				<li><tt>W</tt> - выгружен на диск;</li>
				<li><tt><</tt> - имеет повышенный приоритет;</li>
				<li><tt>N</tt> - имеет пониженный приоритет;</li>
				<li><tt>L</tt> - некоторые страницы блокированы в ядре;</li>
				<li><tt>s</tt> - процесс является лидером сеанса.</li>
			</ol>	
		</td>
	</tr>
	<tr>
		<td><tt>TIME</tt></td>
		<td>Кол-во времени ЦП, затраченное на выполнение процесса</td>
	</tr>
	<tr>
		<td><tt>COMMAND</tt></td>
		<td>Имя аргумента и команды. Программы могут модифицировать эту информацию, поэтому в этой колонке не для всех процессов может быть получена достоверная информация. Команды в скобках (в колонке <em>COMMAND</em>) являются потоками ядра, запланированными в качестве процессов.</td>
	</tr>
</table>

<p>Пользователям и администраторам часто приходится искать нужный процесс среди большого спика процессов из вывода <tt>ps</tt>. Тогда объедините эту программу с <tt>grep</tt> в пайп:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
ps aux |grep "<em>vim</em>"
</pre></td></tr></table>

<p>Замените <em><tt>vim</tt></em> на имя нужного вам процесса. Но обратите внимание, что вывод будет включать в себя и программу <tt>grep</tt>, так как этот процесс был активен во время выполнения <tt>ps</tt> (мы же объединили эти две программы в пайп). Чтобы этого избежать, используйте <tt>grep -v</tt>:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
ps aux |grep -v grep |grep "<em>vim</em>"
</pre></td></tr></table>

<p>Так же (для определения PID процесса) можно использовать <tt>pgrep</tt>:</p>

<table border="1" width="100%" cellpadding="5"><colgroup>
	<col style="background-color:#eeddcc">
</colgroup>
<tr><td>
<pre>
pgrep <em>vim</em>
</pre></td></tr></table>

<p><img src="pic/pgrep.png"></img></p>

<p><em>Красным выделены значения PID нужного процесса <tt>vim</tt></em></p>

<h3>Использование <tt>top</tt> для интерактивного мониторинга процессов</h3>

<p><img src="pic/top.png"></img></p>

<p>На скриншоте выше виден вывод утилиты <tt>top</tt>. По умолчанию, информация из вывода обновляется каждые 10 секунд. На первых строках вывода в сжатом виде представлена информация о нагрузке системы, кол-ве процессов, использовании процессора и пр.</p>

<p>Так же есть более удобная утилита <tt>htop</tt>, так же предназначенная для работы с процессами. Установите его из портов (<tt>console/htop</tt></p>